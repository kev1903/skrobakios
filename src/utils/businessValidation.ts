import { Company } from '@/types/company';

export interface BusinessIssue {
  id: string;
  companyId: string;
  type: 'duplicate' | 'incomplete' | 'test_data' | 'invalid_format';
  severity: 'high' | 'medium' | 'low';
  description: string;
  suggestedAction: 'merge' | 'delete' | 'verify' | 'complete';
}

export interface DuplicateGroup {
  id: string;
  companies: Company[];
  similarity: number;
  mergeCandidate?: Company;
}

export const identifyBusinessIssues = (companies: Company[]): BusinessIssue[] => {
  const issues: BusinessIssue[] = [];

  companies.forEach(company => {
    // Check for test/placeholder data
    if (isTestData(company)) {
      issues.push({
        id: `test-${company.id}`,
        companyId: company.id,
        type: 'test_data',
        severity: 'high',
        description: `Test company: "${company.name}" appears to be test data`,
        suggestedAction: 'delete'
      });
    }

    // Check for incomplete onboarding
    if (!company.onboarding_completed && !hasMinimumInfo(company)) {
      issues.push({
        id: `incomplete-${company.id}`,
        companyId: company.id,
        type: 'incomplete',
        severity: 'medium',
        description: `Incomplete company: "${company.name}" has not completed onboarding`,
        suggestedAction: 'delete'
      });
    }

    // Check for invalid format (auto-generated names)
    if (isAutoGenerated(company)) {
      issues.push({
        id: `invalid-${company.id}`,
        companyId: company.id,
        type: 'invalid_format',
        severity: 'medium',
        description: `Auto-generated company: "${company.name}" has generic naming`,
        suggestedAction: 'verify'
      });
    }
  });

  return issues;
};

export const findDuplicateGroups = (companies: Company[]): DuplicateGroup[] => {
  const groups: DuplicateGroup[] = [];
  const processed = new Set<string>();

  companies.forEach(company => {
    if (processed.has(company.id)) return;

    const duplicates = companies.filter(other => 
      other.id !== company.id && 
      !processed.has(other.id) && 
      areSimilar(company, other)
    );

    if (duplicates.length > 0) {
      const allCompanies = [company, ...duplicates];
      allCompanies.forEach(c => processed.add(c.id));

      groups.push({
        id: `group-${company.id}`,
        companies: allCompanies,
        similarity: calculateSimilarity(company, duplicates[0]),
        mergeCandidate: findBestCandidate(allCompanies)
      });
    }
  });

  return groups;
};

const isTestData = (company: Company): boolean => {
  const testPatterns = [
    /test/i,
    /demo/i,
    /sample/i,
    /temp/i,
    /placeholder/i,
    /^company\d*$/i
  ];

  return testPatterns.some(pattern => 
    pattern.test(company.name) || 
    (company.slug && pattern.test(company.slug))
  );
};

const hasMinimumInfo = (company: Company): boolean => {
  return !!(
    company.phone || 
    company.website || 
    company.abn || 
    company.address ||
    company.industry !== 'Construction'
  );
};

const isAutoGenerated = (company: Company): boolean => {
  // Check for email-based auto-generated names
  const emailPattern = /^[^\s@]+@[^\s@]+\.[^\s@]+'s Company$/;
  const timestampPattern = /-\d{13}\.\d+$/; // Timestamp pattern in slug
  
  return emailPattern.test(company.name) || 
         (company.slug && timestampPattern.test(company.slug));
};

const areSimilar = (company1: Company, company2: Company): boolean => {
  // Similar names (ignoring email prefixes and timestamps)
  const cleanName1 = cleanCompanyName(company1.name);
  const cleanName2 = cleanCompanyName(company2.name);
  
  if (cleanName1 === cleanName2) return true;
  
  // Same ABN
  if (company1.abn && company2.abn && company1.abn === company2.abn) return true;
  
  // Same website
  if (company1.website && company2.website && 
      normalizeUrl(company1.website) === normalizeUrl(company2.website)) return true;
  
  return false;
};

const cleanCompanyName = (name: string): string => {
  return name
    .replace(/^[^\s@]+@[^\s@]+\.[^\s@]+'s /, '') // Remove email prefix
    .replace(/Company$/, '') // Remove "Company" suffix
    .trim()
    .toLowerCase();
};

const normalizeUrl = (url: string): string => {
  return url.replace(/^https?:\/\//, '').replace(/\/$/, '').toLowerCase();
};

const calculateSimilarity = (company1: Company, company2: Company): number => {
  let score = 0;
  let factors = 0;

  // Name similarity
  if (cleanCompanyName(company1.name) === cleanCompanyName(company2.name)) {
    score += 40;
  }
  factors++;

  // ABN match
  if (company1.abn && company2.abn) {
    if (company1.abn === company2.abn) score += 30;
    factors++;
  }

  // Website match
  if (company1.website && company2.website) {
    if (normalizeUrl(company1.website) === normalizeUrl(company2.website)) score += 20;
    factors++;
  }

  // Phone match
  if (company1.phone && company2.phone) {
    if (company1.phone === company2.phone) score += 10;
    factors++;
  }

  return Math.round(score / factors);
};

const findBestCandidate = (companies: Company[]): Company => {
  return companies.reduce((best, current) => {
    const bestScore = getCompanyScore(best);
    const currentScore = getCompanyScore(current);
    return currentScore > bestScore ? current : best;
  });
};

const getCompanyScore = (company: Company): number => {
  let score = 0;
  
  if (company.onboarding_completed) score += 30;
  if (company.verified) score += 20;
  if (company.abn) score += 15;
  if (company.website) score += 10;
  if (company.phone) score += 10;
  if (company.address) score += 5;
  if (!isAutoGenerated(company)) score += 20;
  
  return score;
};

export const generateCleanupSummary = (issues: BusinessIssue[]): string => {
  const counts = issues.reduce((acc, issue) => {
    acc[issue.type] = (acc[issue.type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  const parts = [];
  if (counts.test_data) parts.push(`${counts.test_data} test companies`);
  if (counts.incomplete) parts.push(`${counts.incomplete} incomplete registrations`);
  if (counts.invalid_format) parts.push(`${counts.invalid_format} auto-generated entries`);
  if (counts.duplicate) parts.push(`${counts.duplicate} duplicates`);

  return `Found: ${parts.join(', ')}`;
};