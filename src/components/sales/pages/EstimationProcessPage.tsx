import React, { useState, useRef, useEffect, useCallback } from 'react';
import { useNavigate, useParams } from 'react-router-dom';
import { PageShell } from '@/components/layout/PageShell';
import { StepTimeline } from '@/components/ui/step-timeline';
import { Button } from '@/components/ui/button';
import { ArrowLeft, Save, Indent, Outdent, Plus } from 'lucide-react';
import { useEstimateContext } from '../context/EstimateContext';
import { EstimationWBSTable } from '../components/estimation/EstimationWBSTable';
import { supabase } from '@/integrations/supabase/client';
import { toast } from 'sonner';

export const EstimationProcessPage = () => {
  const steps = [
    { id: 1, title: 'Step 1: Upload & AI Analysis' },
    { id: 2, title: 'Step 2: Take-Off' },
    { id: 3, title: 'Step 3: Estimation Process' },
    { id: 4, title: 'Step 4: Output & Integration' },
  ];
  const navigate = useNavigate();
  const { estimateId } = useParams<{ estimateId: string }>();
  const { estimateTitle, projectType } = useEstimateContext();
  const tableRef = useRef<any>(null);
  const [isSaving, setIsSaving] = useState(false);
  const [isLoading, setIsLoading] = useState(true);
  const autoSaveTimeoutRef = useRef<NodeJS.Timeout | null>(null);
  const [lastSaved, setLastSaved] = useState<Date | null>(null);

  // Load existing estimation data on mount
  useEffect(() => {
    const loadEstimationData = async () => {
      if (!estimateId) return;

      try {
        const { data, error } = await supabase
          .from('estimate_line_items')
          .select('*')
          .eq('estimate_id', estimateId)
          .order('sort_order', { ascending: true });

        if (error) throw error;

        if (data && data.length > 0) {
          const loadedItems = data.map((item) => ({
            id: item.id,
            wbsNumber: item.wbs_number || '',
            name: item.item_description || '',
            level: item.level || 0,
            isExpanded: item.is_expanded || false,
            quantity: item.quantity || 0,
            unit: item.unit || '',
            unitRate: item.unit_price || 0,
            totalCost: item.line_total || 0
          }));
          
          tableRef.current?.setData(loadedItems);
        }
      } catch (error) {
        console.error('Error loading estimation data:', error);
        toast.error('Failed to load estimation data');
      } finally {
        setIsLoading(false);
      }
    };

    loadEstimationData();
  }, [estimateId]);
  
  const handleIndent = () => {
    tableRef.current?.indentSelected();
  };

  const handleOutdent = () => {
    tableRef.current?.outdentSelected();
  };

  const handleSave = async () => {
    if (!estimateId) {
      toast.error('No estimate ID found');
      return;
    }

    setIsSaving(true);
    try {
      const data = tableRef.current?.getData();
      
      if (!data || data.length === 0) {
        setIsSaving(false);
        return;
      }

      // Delete existing line items for this estimate
      const { error: deleteError } = await supabase
        .from('estimate_line_items')
        .delete()
        .eq('estimate_id', estimateId);

      if (deleteError) throw deleteError;

      // Prepare line items for insertion (line_total is auto-generated by database)
      const lineItems = data.map((item: any, index: number) => ({
        estimate_id: estimateId,
        wbs_number: item.wbsNumber,
        item_description: item.name,
        quantity: item.quantity || 0,
        unit: item.unit || '',
        unit_price: item.unitRate || 0,
        level: item.level || 0,
        is_expanded: item.isExpanded || false,
        sort_order: index
      }));

      // Insert new line items
      const { error: insertError } = await supabase
        .from('estimate_line_items')
        .insert(lineItems);

      if (insertError) throw insertError;

      setLastSaved(new Date());
      toast.success('Estimation data saved successfully');
    } catch (error) {
      console.error('Error saving estimation data:', error);
      toast.error('Failed to save estimation data');
    } finally {
      setIsSaving(false);
    }
  };

  // Auto-save function with debouncing
  const handleAutoSave = useCallback(async () => {
    if (!estimateId || isSaving) return;

    try {
      const data = tableRef.current?.getData();
      
      // Only skip save if explicitly no data (not just empty array from initial load)
      if (!data) return;

      // Delete existing line items for this estimate
      const { error: deleteError } = await supabase
        .from('estimate_line_items')
        .delete()
        .eq('estimate_id', estimateId);

      if (deleteError) throw deleteError;

      // Prepare line items for insertion (line_total is auto-generated by database)
      const lineItems = data.map((item: any, index: number) => ({
        estimate_id: estimateId,
        wbs_number: item.wbsNumber,
        item_description: item.name,
        quantity: item.quantity || 0,
        unit: item.unit || '',
        unit_price: item.unitRate || 0,
        level: item.level || 0,
        is_expanded: item.isExpanded || false,
        sort_order: index
      }));

      // Insert new line items
      const { error: insertError } = await supabase
        .from('estimate_line_items')
        .insert(lineItems);

      if (insertError) throw insertError;

      setLastSaved(new Date());
    } catch (error) {
      console.error('Auto-save error:', error);
    }
  }, [estimateId, isSaving]);

  // Handle data changes with debounced auto-save
  const handleDataChange = useCallback((data: any) => {
    // Clear existing timeout
    if (autoSaveTimeoutRef.current) {
      clearTimeout(autoSaveTimeoutRef.current);
    }

    // Set new timeout for auto-save (2 seconds after user stops typing)
    autoSaveTimeoutRef.current = setTimeout(() => {
      handleAutoSave();
    }, 2000);
  }, [handleAutoSave]);

  // Cleanup timeout on unmount
  useEffect(() => {
    return () => {
      if (autoSaveTimeoutRef.current) {
        clearTimeout(autoSaveTimeoutRef.current);
      }
    };
  }, []);

  const handleStepChange = (s: number) => {
    const id = estimateId;
    if (!id) return;
    switch (s) {
      case 1: navigate(`/estimates/edit/${id}`); break;
      case 2: navigate(`/estimates/edit/${id}/take-off`); break;
      case 3: navigate(`/estimates/edit/${id}/estimation`); break;
      case 4: navigate(`/estimates/edit/${id}/output`); break;
    }
  };
  return (
    <PageShell withPattern>
      <div className="flex flex-col h-[calc(100vh-var(--header-height,64px))]">
        {/* Combined Toolbar: Back button + Steps + Action buttons */}
        <div className="shrink-0 px-6 py-3 border-b border-border/30 bg-white/80 backdrop-blur-xl">
          <div className="flex items-center gap-4 w-full">
            {/* Left: Back button */}
            <Button variant="ghost" size="sm" onClick={() => navigate(-1)} className="shrink-0">
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back
            </Button>

            {/* Center: Step Timeline */}
            <div className="flex-1 min-w-0">
              <StepTimeline steps={steps} current={3} onChange={handleStepChange} />
            </div>

            {/* Right: Action buttons */}
            <div className="flex items-center gap-2 shrink-0">
              <Button variant="outline" size="sm" onClick={handleOutdent}>
                <Outdent className="w-4 h-4 mr-2" />
                Outdent
              </Button>
              <Button variant="outline" size="sm">
                <Plus className="w-4 h-4 mr-2" />
                Add Item
              </Button>
              <Button variant="outline" size="sm" onClick={handleIndent}>
                <Indent className="w-4 h-4 mr-2" />
                Indent
              </Button>
              <Button variant="default" size="sm" onClick={handleSave} disabled={isSaving}>
                <Save className="w-4 h-4 mr-2" />
                {isSaving ? 'Saving...' : 'Save'}
              </Button>
            </div>
          </div>
        </div>

        {/* Main Content */}
        <div className="flex-1 overflow-hidden">
          <EstimationWBSTable 
            ref={tableRef}
            onDataChange={handleDataChange}
          />
        </div>
        
        {/* Auto-save indicator */}
        {lastSaved && (
          <div className="absolute bottom-4 right-4 text-xs text-muted-foreground bg-background/80 backdrop-blur-sm px-3 py-1.5 rounded-full border border-border/30">
            Last saved: {lastSaved.toLocaleTimeString()}
          </div>
        )}
      </div>
    </PageShell>
  );
};
